#!/usr/bin/python
# PYTHON_ARGCOMPLETE_OK

import os.path
import sys
import subprocess
import argparse
import string
import xmlrpclib
import logging
import re
from icolor import cformat
import traceback
import socket
import base64
import websocket
import json
import argcomplete


# --- Set some variables

dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
version = "0.0.1-SNAPSHOT"
jarname = "experimaestro-%s.jar" % version

logging.basicConfig(level=logging.INFO)


    
# --- Check paths


def jarpaths():
    """Returns the different paths where the JAR file can be located"""
    yield os.path.join(dir, jarname)
    yield os.path.join(dir, "target", "experimaestro-%s-bin" % version, jarname)


def start_jar(args, jarargs):
    # Check what if we start using maven
    mvnFile = os.path.join(dir, "pom.xml")
    if not os.path.exists(mvnFile):
        mvnFile = None

    if args.maven or mvnFile is not None:
        logging.info("Starting with maven")
        command = ["mvn", "exec:java", "-Dexec.mainClass=bpiwowar.experiments.Run"]
        if mvnFile is not None:
            command.append("--file")
            command.append(mvnFile)
        jarargs = [arg for arg in jarargs]
        command.append("-Dexec.args=%s" % string.join(jarargs, " "))

    else:
        jarpath = None
        for f in jarpaths():
            print "Trying %s" % f
            if os.path.isfile(f):
                jarpath = f
                break

        if jarpath is None:
            raise Exception("Could not find experimaestro jar file")
        command = ["java", "-Xmx1g", "-jar", jarpath] + jarargs

    # print command
    logging.debug('Running command %s' % command)
    subprocess.call(command)


class Properties:
    def __init__(self, map=[None, {}]):
        self.map = map

    def __len__(self):
        return len(self.map[1])

    def __getitem__(self, name):
        v = self.sub(name, None)
        if v is None:
            raise Exception("No key %s in properties" % name)
        return v.map[0]

    def keys(self):
        return self.map[1].keys()

    def get(self, name, default=None):
        v = self.sub(name, None)
        if v is None:
            return None
        return v.map[0]

    def __str__(self):
        return "Properties (%s)" % self.map.__str__()
        
    def __iter__(self):
        for k,v in self.map[1].iteritems():
            yield k,Properties(v)

    def sub(self, name, default=None):
        c = self.map
        for k in name.split("."):
            if not k in c[1]:
                return default
            else:
                c = c[1][k]
        return Properties(c)

    def set(self, name, value):
        c = self.map
        for k in name.split("."):
            if not k in c[1]:
                c[1][k] = [None, {}]
            c = c[1][k]

        c[0] = value


def getProperties(filename):
    """Get a dictionnary from a property file
   """
    propFile = file(filename, "rU")

    re_comment = re.compile(r"""[#;].*""")
    re_section = re.compile(r"""^\[(\w+)\]$""")
    re_value = re.compile(r"""([\w.]+)\s*=\s*(\S*)\s*""")

    # Set some default values
    props = Properties()
    section = ""

    # Read the properties
    for propLine in propFile:
        propDef = propLine.strip()
        if len(propDef) == 0 or re_comment.match(propDef):
            continue

        m = re_section.match(propDef)
        if m is not None:
            section = m.group(1) + "."
            continue

        m = re_value.match(propDef)
        if m is not None:
            props.set(section + m.group(1), m.group(2))
            continue

        raise Exception("Could not read line [%s]" % propDef)

    propFile.close()
    return props

class Configuration():
    def __init__(self, args):
        """Get the configuration from command line and configuration file"""
    
        # Get the configuration
        configfile = os.path.expanduser(args.config)

        # Initialise the server
        config = getProperties(configfile)

        clients = config.sub("client", None)
        if clients is None:
            raise Exception("No client section in configuration file")

        
        if args.server is None:
            if len(clients) > 1:
                args.server = None
                for name,client in clients:
                    if client.get("default", False) == "true":
                        if args.server is None:
                            args.server = name
                        else:
                            raise Exception("More than one client defined as default in configuration file")
                if args.server is None:
                    raise Exception("More than one client [%d] in configuration file (%s): use the --server option or make one client the default" 
                        % (len(clients), ",".join(clients.keys())))
            else:
                args.server = clients.keys()[0]

        self.client = clients.sub(args.server)
        self.remote = self.client.get("remote", False) in ["true", "True", "1"]
        
    def getServer(self):
        return xmlrpclib.ServerProxy("%s/xmlrpc" % self.client["url"], verbose=args.verbose)
        
    def getStreamServer(self):    
        re_url = re.compile("""http(s)?://(?:([^:@]+):([^@]+)@)?(.+)$""")
        m = re_url.match(self.client["url"])
        if not m:
            raise "Client URL is not valid"
        
        scheme = "ws"
        if m.group(1): 
            secure = "wss"
        url = "%s://%s/web-socket" % (scheme, m.group(4))
        
        header = []
        if m.group(2) and m.group(3):
            auth = base64.b64encode("%s:%s" % (m.group(2), m.group(3)))
            header = [ "Authorization: Basic %s" % auth ]
        
        return websocket.create_connection(url, header=header)

    
# --- Server


def command_server_start(args):
    start_jar(args, ["server"])


def command_stop_server(args):
    server = Configuration(args).getServer()
    server.Server.shutdown()


def command_run_js(appendrgs):
    conf = Configuration(args)
    client = conf.getStreamServer()
    
    # Get the command line
    files = []

    if args.pre:
        files.append(["<pre>", args.pre]);

    for filename in args.files:
        filepath = os.path.abspath(filename)
        if not conf.remote:
            files.append([filepath, None])
        else:
            files.append([filepath, file(filepath).read()])

    if args.post:
        files.append(["<post>", args.post]);

    logging.debug("Running JS scripts %s" % [s[0] for s in files])

    try:
        code = 0
        msg = json.dumps({"command": "run-javascript", "args": { "files": files, "environment": dict(os.environ)}})
        r = client.send(msg)
        while client is not None:
            message = client.recv()
            o = json.loads(message)
            if type(o) == dict:
                code = o["code"]
                print "Exit code: %s" % o["code"]
                if "message" in o:
                    print o["message"]
                break
            else:
                print o,
            
        sys.exit(code)
    except xmlrpclib.Fault as e:
        print e
        sys.exit(1)
    except Exception as e:
        print e
        sys.exit(1)


def command_update(args):
    server = Configuration(args).getServer()
    print "%d updated job(s)" % server.Server.updateJobs(args.group, args.recursive, get_states(args.states))


def command_ls(args):
    server = Configuration(args).getServer()
    response = server.Server.listJobs(args.group, get_states(args.states))
    for l in response:
        state = l.get("state", "?").upper()
        if state == 'ERROR':
            print cformat("#RED;%s" % l)
        elif state == 'DONE':
            print cformat("#GREEN;%s" % l)
        elif state == 'RUNNING':
            print cformat("#CYAN;%s" % l)
        elif state == 'ON_HOLD':
            print cformat("#YELLOW;%s" % l)
        else:
            print l


def command_list_methods(args):
    server = Configuration(args).getServer()
    for method in server.system.listMethods():
        if not method.startswith("system"):
            print("# %s" % method)
            print server.system.methodSignature(method)
            print server.system.methodHelp(method)
            print


def command_information(args):
    server = Configuration(args).getServer()
    print server.Server.getResourceInformation(args.resourceId[0])


def command_invalidate(args):
    server = Configuration(args).getServer()
    print server.Server.invalidateJob(args.resourceId[0], args.recursive)


def command_kill(args):
    server = Configuration(args).getServer()
    n = server.Server.kill(args.jobid)
    print "Killed %d jobs" % n


def command_rm(args):
    server = Configuration(args).getServer()
    if len(args.jobid) == 0:
        args.jobid = [""]

    states = get_states(args.states)
    if args.group is None:
        args.group = ""

    for jobid in args.jobid:
        n = server.Server.remove(args.group, jobid, states)
        print "Removed %d resources" % n


def command_log_level(args):
    server = Configuration(args).getServer()
    server.Server.setLogLevel(args.id, args.level)

# --- Utility functions


def get_states(states):
    if states is not None:
        states = args.states.split(",")
    else:
        states = []
    return states


# --- Run command


# create the top-level parser
parser = argparse.ArgumentParser(description='experimaestro script.')
subparsers = parser.add_subparsers(help='Command', dest='command')
parser.set_defaults(dir=dir)
parser.add_argument("--log", dest="loglevel", action="store", help="Log level",
                    choices=["debug", "info", "warn"], default="info")
parser.add_argument("--maven", dest="maven", action="store_true", help="Force starts using maven")
parser.add_argument("--debug", dest="debug", action="store_true", help="Debug script")
parser.add_argument("--verbose", dest="verbose", action="store_true", help="Use verbose mode for XML-RPC server")
parser.add_argument("--config", dest="config", default="~/.experimaestro", action="store",
                    help="Experimaestro configuration file")
parser.add_argument("--server", dest="server", action="store", help="The experimaestro server to use")

subparser = subparsers.add_parser("start-server", help="Start the experimaestro server")

subparser = subparsers.add_parser("stop-server", help="Stop the experimaestro server")

p_run_js = subparsers.add_parser("run-js", help="Run JavaScript script in server")
p_run_js.add_argument("--remote", dest="remote", action="store_true", help="For the remote mode (files should be transmitted)")
p_run_js.add_argument("--pre", dest="pre", help="Execute this javascript before the files")
p_run_js.add_argument("--post", dest="post", help="Execute this javascript after the files")
p_run_js.add_argument('files', nargs='*', help='')


job_specification = argparse.ArgumentParser(add_help=False)
job_specification.add_argument('--states', dest="states", help="States")
job_specification.add_argument('group', nargs='?', help="The group to list", default="")
job_specification.add_argument('--recursive', dest="recursive", action="store_true", default=False, help="Should dependent resources be invalidated?")

subparsers.add_parser("update", help="Update jobs", parents=[job_specification])

p_ls = subparsers.add_parser("ls", help="List jobs", parents=[job_specification])

subparsers.add_parser("list-methods", help="List XML-RPC methods")

p_invalidate = subparsers.add_parser("invalidate", help="Invalidate a job")
p_invalidate.add_argument('resourceId', nargs=1, help='The resource URI')

p_information = subparsers.add_parser("information", help="Get information on a resource")
p_information.add_argument('resourceId', nargs=1, help='The resource URI')

p_rm = subparsers.add_parser("rm", help="Remove a resource")
p_rm.add_argument('--states', dest="states", help="States")
p_rm.add_argument('--group', dest="group")
p_rm.add_argument('jobid', nargs="*", help="The job ids")

p_kill = subparsers.add_parser("kill", help="Kill a job")
p_kill.add_argument('jobid', nargs="+", help="The job URIs")

p_log_level = subparsers.add_parser("log-level", help="Set the logger level")
p_log_level.add_argument('id', nargs=1, help='The logger ID')
p_log_level.add_argument('level', nargs=1, choices=["DEBUG", "INFO", "WARN", "ERROR", "FATAL"], help='The level')

# Parse arguments
args = parser.parse_args()
argcomplete.autocomplete(args)

numeric_level = getattr(logging, args.loglevel.upper(), None)
if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % args.loglevel)

try:
    fname = "command_%s" % args.command.replace("-", "_")
    locals()[fname](args)
except Exception as e:
    print e
    if args.debug:
        print traceback.format_exc()
    sys.exit(1)
