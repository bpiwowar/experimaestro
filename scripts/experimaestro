#!/usr/bin/python

import os.path
import sys
import subprocess
import argparse
import string
import xmlrpclib
import logging
import re
from icolor import cformat
import traceback

# --- Set some variables

dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
version = "0.0.1-SNAPSHOT"
jarname = "experimaestro-%s.jar" % version

logging.basicConfig(level=logging.INFO)

# --- Check paths


def jarpaths():
    """Returns the different paths where the JAR file can be located"""
    yield os.path.join(dir, jarname)
    yield os.path.join(dir, "target", "experimaestro-%s-bin" % version, jarname)


def start_jar(args, jarargs):
    # Check what if we start using maven
    mvnFile = os.path.join(dir, "pom.xml")
    if not os.path.exists(mvnFile):
        mvnFile = None

    if args.maven or mvnFile is not None:
        logging.info("Starting with maven")
        command = ["mvn", "exec:java", "-Dexec.mainClass=bpiwowar.experiments.Run"]
        if mvnFile is not None:
            command.append("--file")
            command.append(mvnFile)
        jarargs = [arg for arg in jarargs]
        command.append("-Dexec.args=%s" % string.join(jarargs, " "))

    else:
        jarpath = None
        for f in jarpaths():
            print "Trying %s" % f
            if os.path.isfile(f):
                jarpath = f
                break

        if jarpath is None:
            raise Exception("Could not find experimaestro jar file")
        command = ["java", "-Xmx1g", "-jar", jarpath] + jarargs

    # print command
    logging.debug('Runnig command %s' % command)
    subprocess.call(command)


class Properties:
    def __init__(self, map=[None, {}]):
        self.map = map

    def __len__(self):
        return len(self.map[1])

    def __getitem__(self, name):
        v = self.sub(name, None)
        if v is None:
            raise Exception("No key %s in properties" % name)
        return v.map[0]

    def keys(self):
        return self.map[1].keys()

    def get(self, name, default=None):
        v = self.sub(name, None)
        if v is None:
            return None
        return v.map[0]

    def __str__(self):
        return "Properties (%s)" % self.map.__str__()
        
    def __iter__(self):
        for k,v in self.map[1].iteritems():
            yield k,Properties(v)

    def sub(self, name, default=None):
        c = self.map
        for k in name.split("."):
            if not k in c[1]:
                return default
            else:
                c = c[1][k]
        return Properties(c)

    def set(self, name, value):
        c = self.map
        for k in name.split("."):
            if not k in c[1]:
                c[1][k] = [None, {}]
            c = c[1][k]

        c[0] = value


def getProperties(filename):
    """Get a dictionnary from a property file
   """
    propFile = file(filename, "rU")

    re_comment = re.compile(r"""[#;].*""")
    re_section = re.compile(r"""^\[(\w+)\]$""")
    re_value = re.compile(r"""([\w.]+)\s*=\s*(\S*)\s*""")

    # Set some default values
    props = Properties()
    section = ""

    # Read the properties
    for propLine in propFile:
        propDef = propLine.strip()
        if len(propDef) == 0 or re_comment.match(propDef):
            continue

        m = re_section.match(propDef)
        if m is not None:
            section = m.group(1) + "."
            continue

        m = re_value.match(propDef)
        if m is not None:
            props.set(section + m.group(1), m.group(2))
            continue

        raise Exception("Could not read line [%s]" % propDef)

    propFile.close()
    return props


def getServer(args):
    # Get the configuration
    configfile = os.path.expanduser(args.config)

    # Initialise the server
    config = getProperties(configfile)

    clients = config.sub("client", None)
    if clients is None:
        raise Exception("No client section in configuration file")

        
    if args.server is None:
        if len(clients) > 1:
            args.server = None
            for name,client in clients:
                if client.get("default", False) == "true":
                    if args.server is None:
                        args.server = name
                    else:
                        raise Exception("More than one client defined as default in configuration file")
            if args.server is None:
                raise Exception("More than one client [%d] in configuration file (%s): use the --server option or make one client the default" 
                    % (len(clients), ",".join(clients.keys())))
        else:
            args.server = clients.keys()[0]

    client = clients.sub(args.server)
    rpc = xmlrpclib.ServerProxy(client["url"], verbose=args.verbose)
    remote = client.get("remote", False) in ["true", "True", "1"]

    return (rpc, remote)

# --- Server


def command_server_start(args):
    start_jar(args, ["server"])


def command_stop_server(args):
    (server, remote) = getServer(args)
    server.Server.shutdown()


def command_run_js(args):
    (xmlrpc, remote) = getServer(args)

    env = []
    for key, value in os.environ.iteritems():
        env.append([key, value])

    # Remote mode
    isFile = not(remote)

    # Get the command line
    filepaths = []
    filecontents = []
    for filename in args.files:
        filepath = os.path.abspath(filename)
        filepaths.append(filepath)
        if not remote:
            filecontents.append(False)
        else:
            filecontents.append(file(filepath).read())

    if args.post:
        filepaths.append("<post>");
        filecontents.append(args.post);

    logging.debug("Running JS scripts %s" % filepaths)

    try:
        r = xmlrpc.Server.runJSScript(filepaths, filecontents, env)
        if len(r) > 2:
            print(r[2])
        if r[0]:
            print
            print "### Error while running %s ###" % filename
            print r[1]
            sys.exit(r[0])
            print
    except xmlrpclib.Fault as e:
        print e
        sys.exit(1)
    except Exception as e:
        print e
        sys.exit(1)


def command_update_jobs(args):
    (server, remote) = getServer(args)
    print "%d updated job(s)" % server.Server.updateJobs("", False, [])


def command_ls(args):
    (server, remote) = getServer(args)
    response = server.Server.listJobs(args.group, get_states(args.states))
    for l in response:
        state = l.get("state", "?")
        if state == 'ERROR':
            print cformat("#RED;%s" % l)
        elif state == 'DONE':
            print cformat("#GREEN;%s" % l)
        elif state == 'RUNNING':
            print cformat("#CYAN;%s" % l)
        else:
            print l


def command_list_methods(args):
    (server, remote) = getServer(args)
    for method in server.system.listMethods():
        if not method.startswith("system"):
            print("# %s" % method)
            print server.system.methodSignature(method)
            print server.system.methodHelp(method)
            print


def command_information(args):
    (server, remote) = getServer(args)
    print server.Server.getResourceInformation(args.resourceId[0])


def command_invalidate(args):
    (server, remote) = getServer(args)
    print server.Server.invalidateJob(args.resourceId[0], args.recursive)


def command_kill(args):
    (server, remote) = getServer(args)
    n = server.Server.kill(args.jobid)
    print "Killed %d jobs" % n


def command_rm(args):
    (server, remote) = getServer(args)
    if len(args.jobid) == 0:
        args.jobid = [""]

    states = get_states(args.states)
    if args.group is None:
        args.group = ""

    for jobid in args.jobid:
        n = server.Server.remove(args.group, jobid, states)
        print "Removed %d resources" % n


def command_log_level(args):
    (server, remote) = getServer(args)
    server.Server.setLogLevel(args.id, args.level)

# --- Utility functions


def get_states(states):
    if states is not None:
        states = args.states.split(",")
    else:
        states = []
    return states


# --- Run command


# create the top-level parser
parser = argparse.ArgumentParser(description='experimaestro script.')
subparsers = parser.add_subparsers(help='sub-command help', dest='command')
parser.set_defaults(dir=dir)
parser.add_argument("--log", dest="loglevel", action="store", help="Log level",
                    choices=["debug", "info", "warn"], default="info")
parser.add_argument("--maven", dest="maven", action="store_true", help="Force starts using maven")
parser.add_argument("--debug", dest="debug", action="store_true", help="Debug script")
parser.add_argument("--verbose", dest="verbose", action="store_true", help="Use verbose mode for XML-RPC server")
parser.add_argument("--config", dest="config", default="~/.experimaestro", action="store",
                    help="Experimaestro configuration file")
parser.add_argument("--server", dest="server", action="store", help="The experimaestro server to use")

subparser = subparsers.add_parser("start-server", help="Start the experimaestro server")

subparser = subparsers.add_parser("stop-server", help="Stop the experimaestro server")

p_run_js = subparsers.add_parser("run-js", help="Run JavaScript script in server")
p_run_js.add_argument("--remote", dest="remote", action="store_true", help="For the remote mode (files should be transmitted)")
p_run_js.add_argument("--post", dest="post", help="Execute this javascript after the files")
p_run_js.add_argument('files', nargs='*', help='')

subparsers.add_parser("update-jobs", help="Update jobs")

p_ls = subparsers.add_parser("ls", help="List jobs")
p_ls.add_argument('--states', dest="states", help="States")
p_ls.add_argument('group', nargs='?', help="The group to list", default="")

subparsers.add_parser("list-methods", help="List XML-RPC methods")

p_invalidate = subparsers.add_parser("invalidate", help="Invalidate a job")
p_invalidate.add_argument('--recursive', dest="recursive", action="store_true", default=False, help="Should dependent resources be invalidated?")
p_invalidate.add_argument('resourceId', nargs=1, help='The resource URI')

p_information = subparsers.add_parser("information", help="Get information on a resource")
p_information.add_argument('resourceId', nargs=1, help='The resource URI')

p_rm = subparsers.add_parser("rm", help="Remove a resource")
p_rm.add_argument('--states', dest="states", help="States")
p_rm.add_argument('--group', dest="group")
p_rm.add_argument('jobid', nargs="*", help="The job ids")

p_kill = subparsers.add_parser("kill", help="Kill a job")
p_kill.add_argument('jobid', nargs="+", help="The job URIs")

p_log_level = subparsers.add_parser("log-level", help="Set the logger level")
p_log_level.add_argument('id', nargs=1, help='The logger ID')
p_log_level.add_argument('level', nargs=1, choices=["DEBUG", "INFO", "WARN", "ERROR", "FATAL"], help='The level')

# Parse arguments
args = parser.parse_args()

numeric_level = getattr(logging, args.loglevel.upper(), None)
if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % args.loglevel)

try:
    fname = "command_%s" % args.command.replace("-", "_")
    locals()[fname](args)
except Exception as e:
    print e
    if args.debug:
        print traceback.format_exc()
    sys.exit(1)
