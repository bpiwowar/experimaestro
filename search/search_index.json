{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nTired of bash, python, ... scripts to manage your experiments? Experimaestro manager\ngives you a systematic way to write and run experiments where parameters varies.\nThe goals of the experimaestro manager are to:\n\n\n\n\nDecompose experiments into a set of tasks\n\n\nStandardize the way to run experiments for easier reproduction of experimental results in computing science\n\n\nBuild a documentation for each task\n\n\nUses the scheduler to run jobs on various computational resources\n\n\nProvide multiple ways to write task descriptions. Currently, JavaScript and Python are supported\n\n\nManage data produced by the tasks\n\n\nAssociate tags to ran tasks\n\n\n\n\nExperimaestro is an experiment manager, and is composed of\n\n\n\n\nA \njob scheduler\n that handles dependencies between jobs and provides locking mechanisms\n   The job scheduler can be controlled via command line (\nexperimaestro\n script) or via the web (where\n   you can easily monitor jobs in real time)\n\n\nA \nmodular experiment description framework\n, that allows easy description of the various parts of experiments:\n\n\nExperiments are written in JavaScript or Python\n\n\nTasks describe the components that can be used\n\n\nComposition: tasks take as input json and output json\n\n\nTasks can be composed through the definition of an experimental plan\n\n\n\n\n\n\n\n\nBoth modules can be used independently even though they were designed to work together.\n\n\nExperimaestro is in a \nbeta\n state - which means that you might experience some bugs\nwhile using it; but as I use it on a daily basis, there number and importance is\ngoing down each day.\n\n\n\n\nMain concepts\n\n\nThe main concepts of experimaestro are\n\n\n\n\nAll messages between tasks are \nJSON\n objects. This is described in \nthis document\n.\n\n\nTypes and tasks are the unit on which experiments are built, and correspond roughly to either the execution of a long process, or to a configuration. Tasks can be composed in various ways to allow a compact representation of\n    experimental plans.  Tasks are described further \nthis document\n\n\nComputational resources, named \nconnectors\n, define a set of computers - how can a file be stored, how can a\n    command line be executed. More information can be found in this \ndocument\n.",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "Tired of bash, python, ... scripts to manage your experiments? Experimaestro manager\ngives you a systematic way to write and run experiments where parameters varies.\nThe goals of the experimaestro manager are to:   Decompose experiments into a set of tasks  Standardize the way to run experiments for easier reproduction of experimental results in computing science  Build a documentation for each task  Uses the scheduler to run jobs on various computational resources  Provide multiple ways to write task descriptions. Currently, JavaScript and Python are supported  Manage data produced by the tasks  Associate tags to ran tasks   Experimaestro is an experiment manager, and is composed of   A  job scheduler  that handles dependencies between jobs and provides locking mechanisms\n   The job scheduler can be controlled via command line ( experimaestro  script) or via the web (where\n   you can easily monitor jobs in real time)  A  modular experiment description framework , that allows easy description of the various parts of experiments:  Experiments are written in JavaScript or Python  Tasks describe the components that can be used  Composition: tasks take as input json and output json  Tasks can be composed through the definition of an experimental plan     Both modules can be used independently even though they were designed to work together.  Experimaestro is in a  beta  state - which means that you might experience some bugs\nwhile using it; but as I use it on a daily basis, there number and importance is\ngoing down each day.   Main concepts  The main concepts of experimaestro are   All messages between tasks are  JSON  objects. This is described in  this document .  Types and tasks are the unit on which experiments are built, and correspond roughly to either the execution of a long process, or to a configuration. Tasks can be composed in various ways to allow a compact representation of\n    experimental plans.  Tasks are described further  this document  Computational resources, named  connectors , define a set of computers - how can a file be stored, how can a\n    command line be executed. More information can be found in this  document .",
            "title": "Introduction"
        },
        {
            "location": "/scheduler/",
            "text": "Main concepts\n\n\nThe job scheduler goal is to run interdependent jobs (i.e. one job might need one or several outputs from other jobs)\n\n\n\n\n\n\nResources\n: Any object is a resource, whether it is data, a job, or a server. Resources are located on different hosts\n  that can be specified by a URI. For example, \nfile:///a/b/c\n denotes a local folder or file,\n  while \nxpm:token:user@hostname.org\n corresponds to a token used to limit the number of launched processes on a given computer.\n\n\n\n\n\n\nConnectors\n: Connectors specify how a resource can be accessed and how\n  processes can be launched. \nSingle connectors\n (i.e., localhost and ssh) are built-in.\n  Composite connectors (i.e., describing a cluster of computers) can be built from single connectors.\n\n\n\n\n\n\nResource state\n: A resource can be in the state\n\n\n\n\nWAITING\n (waiting for dependencies to be met),\n\n\nHOLD\n (waiting a user action) consequently to a dependency being in the ERROR or HOLD state.\n\n\nDONE\n when completed,\n\n\nERROR\n.\n\n\n\n\nFor tasks that can be run, two other states are possible:\n\n\n\n\nREADY\n (waiting to be run),\n\n\nRUNNING\n,\n\n\n\n\n\n\n\n\nGroups\n:\n  One should allow to set a group for a set of experiments. For example: I run several series of experiment and call them \"trec.test1\", \"trec.test2\". I can then operate on all the resources of a specific group, like e.g. \"trec\" or \"trec.test1\".\n\n\n\n\n\n\nGeneral architecture\n\n\nResources\n\n\nWe have the following types of resources:\n\n\n\n\n\n\nData: the output of one job (one job can have several outputs). Some data can also be already generated by an external process (e.g. a data collection) and be declared to experimaestro as read. Data can be in three states: \nWAITING\n, \nHOLD\n or \nDONE\n.\n\n\n\n\n\n\nTask:\n\n\n\n\nJob:  a task to be run, that produces a given set of resources.\n\n\nServer: a task that need to be run; however, we don't wait for the server run to complete.\n*\n\n\n\n\n\n\n\n\nStatus\n\n\nEvery resource (see below) has a unique ID which is a path to a directory containing information about the resource on the\n  host.\n\n\nBased on the file \n${FILE}\n, several paths are defined (note that not all files might be present)\n\n\n\n\n${FILE}.lock\n   locks the write access to the status (can also be used as an exclusive lock to the resource)\n    This file is used whenever an exclusive access is needed.\n\n\n${FILE}.status\n  contains the PID of the running process (two columns PID MODE separated by space) where MODE is r, w.\n    This file is used when the resource can be accessed by a single writer and multiple readers\n\n\n${FILE}.run\n  corresponds to the script that are needed to execute the job\n\n\n${FILE}.code\n  corresponds to the error code at the end of the execution of the job\n\n\n${FILE}.done\n created when the job was successfully executed or the data successfully generated\n\n\n${FILE}.err\n  contains the error log output (jobs only)\n\n\n${FILE}.out\n  contains the standard log output (jobs only)\n\n\n${FILE}.input\n  contains the standard input (jobs only)\n\n\n\n\nUsing experimaestro\n\n\nXML-RPC\n\n\nThe Experimaestro server can be reached \nthrough XML-RPC calls\n.",
            "title": "Home"
        },
        {
            "location": "/scheduler/#main-concepts",
            "text": "The job scheduler goal is to run interdependent jobs (i.e. one job might need one or several outputs from other jobs)    Resources : Any object is a resource, whether it is data, a job, or a server. Resources are located on different hosts\n  that can be specified by a URI. For example,  file:///a/b/c  denotes a local folder or file,\n  while  xpm:token:user@hostname.org  corresponds to a token used to limit the number of launched processes on a given computer.    Connectors : Connectors specify how a resource can be accessed and how\n  processes can be launched.  Single connectors  (i.e., localhost and ssh) are built-in.\n  Composite connectors (i.e., describing a cluster of computers) can be built from single connectors.    Resource state : A resource can be in the state   WAITING  (waiting for dependencies to be met),  HOLD  (waiting a user action) consequently to a dependency being in the ERROR or HOLD state.  DONE  when completed,  ERROR .   For tasks that can be run, two other states are possible:   READY  (waiting to be run),  RUNNING ,     Groups :\n  One should allow to set a group for a set of experiments. For example: I run several series of experiment and call them \"trec.test1\", \"trec.test2\". I can then operate on all the resources of a specific group, like e.g. \"trec\" or \"trec.test1\".",
            "title": "Main concepts"
        },
        {
            "location": "/scheduler/#general-architecture",
            "text": "",
            "title": "General architecture"
        },
        {
            "location": "/scheduler/#resources",
            "text": "We have the following types of resources:    Data: the output of one job (one job can have several outputs). Some data can also be already generated by an external process (e.g. a data collection) and be declared to experimaestro as read. Data can be in three states:  WAITING ,  HOLD  or  DONE .    Task:   Job:  a task to be run, that produces a given set of resources.  Server: a task that need to be run; however, we don't wait for the server run to complete.\n*",
            "title": "Resources"
        },
        {
            "location": "/scheduler/#status",
            "text": "Every resource (see below) has a unique ID which is a path to a directory containing information about the resource on the\n  host.  Based on the file  ${FILE} , several paths are defined (note that not all files might be present)   ${FILE}.lock    locks the write access to the status (can also be used as an exclusive lock to the resource)\n    This file is used whenever an exclusive access is needed.  ${FILE}.status   contains the PID of the running process (two columns PID MODE separated by space) where MODE is r, w.\n    This file is used when the resource can be accessed by a single writer and multiple readers  ${FILE}.run   corresponds to the script that are needed to execute the job  ${FILE}.code   corresponds to the error code at the end of the execution of the job  ${FILE}.done  created when the job was successfully executed or the data successfully generated  ${FILE}.err   contains the error log output (jobs only)  ${FILE}.out   contains the standard log output (jobs only)  ${FILE}.input   contains the standard input (jobs only)",
            "title": "Status"
        },
        {
            "location": "/scheduler/#using-experimaestro",
            "text": "",
            "title": "Using experimaestro"
        },
        {
            "location": "/scheduler/#xml-rpc",
            "text": "The Experimaestro server can be reached  through XML-RPC calls .",
            "title": "XML-RPC"
        },
        {
            "location": "/installing/",
            "text": "Scheduler installation\n\n\nRequirements\n\n\nExperimaestro is implemented using several languages and thus, you\nhave to install multiple ecosystem with the right version.\n\n\nPython 3\n\n\nYou need a working \npython3\n interpreter on your system along with \npip3\n.\n\n\nTo install required python's modules type:\n\n\npip3 install -r server/scripts/requirements.txt\n\n\n\n\nJava (\u2265 8)\n\n\nYou need a working \nJava\n installation (version \u2265 1.8) on your machine. \nGradle\n is\nused for building but is not a requirement.\n\n\nOn linux or OS X:\n\n# From the project's root directory.\n\n./gradlew installDist\n\n\n\nOn Windows:\n\ngradlew.bat installDist\n\n\n\nThis will build and install all the dependencies into \nserver/build/install/experimaestro-server\n. The command \nexperimaestro\n is located in \nserver/build/install/experimaestro-server/bin/experimaestro\n.\n\n\nNote that on a Linux box if you are not root and the alternative link\nis not set to the proper version (you can inspect that using\n\nupdate-alternatives --display java\n), you won't have the permission\nto update the link manually using \nupdate-alternatives --config java\n.\nThe work around is to set the environment variable \nJAVA_HOME\n when\ncalling maven. For example:\n\n\nTo locate the path of to set to \nJAVA_HOME\n you can do \nlocate jdk | less\n.\n\n\nThe server and clients are configured by a simple property file \nsettings.ini\n, located in the \n.experimaestro\n (by default) file in the user's home directory.\n\n\nShell completion\n\n\nTo enable shell completion follow instructions in\n\nargcomplete\n documentation.\n\n\nZSH\n\n\nAdd to \n.zshrc\n:\n\n\n  \n# Register python completion\n\n  \nif\n \ntype\n register-python-argcomplete \n&\n> /dev/null\n  \nthen\n\n    \neval\n \n\"\n$(\nregister-python-argcomplete \n'experimaestro'\n)\n\"\n\n  \nfi\n\n\n\n\n\n\n\nRe-launch your shell: \nexec zsh\n\n\n\n\nConfiguration\n\n\nA configuration file must be stored in \n$HOME/.experimaestro/settings.json\n\n\n{\n\n    \n\"server\"\n:\n \n{\n\n        \n\"name\"\n:\n \n\"[name of the server]\"\n,\n\n        \n\"port\"\n:\n \n12345\n,\n\n        \n\"database\"\n:\n \n\"[path to the database]\"\n,\n\n        \n\"passwords\"\n:\n \n[\n\n            \n{\n\n                \n\"user\"\n:\n \n\"[username]\"\n,\n\n                \n\"password\"\n:\n \n\"[plain text password]\"\n,\n\n                \n\"roles\"\n:\n \n[\n \n\"user\"\n \n]\n\n            \n}\n\n        \n]\n\n    \n},\n\n\n    \n\"hosts\"\n:\n \n{\n\n        \n\"local\"\n:\n \n{\n\n            \n\"host\"\n:\n \n\"localhost\"\n,\n\n            \n\"port\"\n:\n \n12345\n,\n\n            \n\"username\"\n:\n \n\"XXXX\"\n,\n\n            \n\"password\"\n:\n \n\"XXXX\"\n\n        \n}\n\n    \n},\n\n\n}\n\n\n\n\n\nThe \nserver\n section contains settings for the experimaestro server, while\nthe \nhosts\n section is used to access easily several experimaestro servers\nby giving them an ID (here \nlocal\n). You can several others.\n\n\nTest your installation\n\n\nTo test your installation is working properly you can try to start a\nserver like this:\n\n\nexperimaestro --verbose --debug start-server\n\n\n\n\nYou should get something like:\n\n\nINFO\n:\nroot\n:\nStarting\n \nwith\n \ngradle\n\n\nINFO\n:\nroot\n:\nWaiting\n \nfor\n \nserver\n \nto\n \nstart\n \n(\nPID\n=\n37851\n)...\n\n\nINFO\n:\nroot\n:\nServer\n \nstarted\n...",
            "title": "Installing"
        },
        {
            "location": "/installing/#scheduler-installation",
            "text": "",
            "title": "Scheduler installation"
        },
        {
            "location": "/installing/#requirements",
            "text": "Experimaestro is implemented using several languages and thus, you\nhave to install multiple ecosystem with the right version.",
            "title": "Requirements"
        },
        {
            "location": "/installing/#python-3",
            "text": "You need a working  python3  interpreter on your system along with  pip3 .  To install required python's modules type:  pip3 install -r server/scripts/requirements.txt",
            "title": "Python 3"
        },
        {
            "location": "/installing/#java-8",
            "text": "You need a working  Java  installation (version \u2265 1.8) on your machine.  Gradle  is\nused for building but is not a requirement.  On linux or OS X: # From the project's root directory. \n./gradlew installDist  On Windows: gradlew.bat installDist  This will build and install all the dependencies into  server/build/install/experimaestro-server . The command  experimaestro  is located in  server/build/install/experimaestro-server/bin/experimaestro .  Note that on a Linux box if you are not root and the alternative link\nis not set to the proper version (you can inspect that using update-alternatives --display java ), you won't have the permission\nto update the link manually using  update-alternatives --config java .\nThe work around is to set the environment variable  JAVA_HOME  when\ncalling maven. For example:  To locate the path of to set to  JAVA_HOME  you can do  locate jdk | less .  The server and clients are configured by a simple property file  settings.ini , located in the  .experimaestro  (by default) file in the user's home directory.",
            "title": "Java (\u2265 8)"
        },
        {
            "location": "/installing/#shell-completion",
            "text": "To enable shell completion follow instructions in argcomplete  documentation.",
            "title": "Shell completion"
        },
        {
            "location": "/installing/#zsh",
            "text": "Add to  .zshrc :     # Register python completion \n   if   type  register-python-argcomplete  & > /dev/null\n   then \n     eval   \" $( register-python-argcomplete  'experimaestro' ) \" \n   fi    Re-launch your shell:  exec zsh",
            "title": "ZSH"
        },
        {
            "location": "/installing/#configuration",
            "text": "A configuration file must be stored in  $HOME/.experimaestro/settings.json  { \n     \"server\" :   { \n         \"name\" :   \"[name of the server]\" , \n         \"port\" :   12345 , \n         \"database\" :   \"[path to the database]\" , \n         \"passwords\" :   [ \n             { \n                 \"user\" :   \"[username]\" , \n                 \"password\" :   \"[plain text password]\" , \n                 \"roles\" :   [   \"user\"   ] \n             } \n         ] \n     }, \n\n     \"hosts\" :   { \n         \"local\" :   { \n             \"host\" :   \"localhost\" , \n             \"port\" :   12345 , \n             \"username\" :   \"XXXX\" , \n             \"password\" :   \"XXXX\" \n         } \n     },  }   The  server  section contains settings for the experimaestro server, while\nthe  hosts  section is used to access easily several experimaestro servers\nby giving them an ID (here  local ). You can several others.",
            "title": "Configuration"
        },
        {
            "location": "/installing/#test-your-installation",
            "text": "To test your installation is working properly you can try to start a\nserver like this:  experimaestro --verbose --debug start-server  You should get something like:  INFO : root : Starting   with   gradle  INFO : root : Waiting   for   server   to   start   ( PID = 37851 )...  INFO : root : Server   started ...",
            "title": "Test your installation"
        },
        {
            "location": "/scheduler/connectors/",
            "text": "Connectors\n describe a computational resource, as for example a single computer (\nsingle host connector\n) or a set of computers. It provides information on how to access the file system and execute commands. At the moment, the following connectors are defined:\n\n\n\n\nLocalhost\n\n\nSSH\n\n\n\n\nLaunchers\n are used to launch commands:\n\n\n\n\nDirect launcher: standard command launching\n\n\nOAR: uses OAR to launch jobs on a cluster\n\n\n\n\n\n\nConnectors\n\n\nA connector defines:\n\n\n\n\nThe main connector used to manage the state of a resource associated with this connector;\n\n\nA way to select a single host connector given some computational requirements (e.g. 1G memory);\n\n\n\n\nLocalhost\n\n\nSSH\n\n\n\n\nLaunchers\n\n\nConnectors are used to connect to a specific computer in order to execute a command or access a file system.\nHere is the list of available connectors:\n\n\nDirect launcher\n\n\n\n\nDirectLauncher\n: Executes a command via a shell script\n\n\n\n\nOAR\n\n\n\n\nOARLauncher\n: Launches a job through OAR\n\n\n\n\nFinding and describing resources\n\n\nIn order to allow full flexibility, resources are described by a URI, which in most cases is a URL (e.g. \nfile://path/to/my/file\n). In order to map back a URI to a connector, Experimaestro has a set of handlers associated with protocols (in order to deal with an URL), and custom handlers can be added.\n\n\nThe same resource can be at different paths depending on the host (i.e. via mounts). In order to deal with that,\n\n\nAvailable connectors\n\n\nGroup\n\n\nDefines a set of connectors\n\n\nLocalhost\n\n\nSSH\n\n\nLauncher\n\n\nLaunchers are used to define how a command is executed.\n  Here is the list of available launchers:\n\n\n\n\n\n\nShLauncher: runs commands using the \nsh\n shell\n\n\n\n\n\n\nOARLauncher: runs commands using \nOAR",
            "title": "Connectors & Launchers"
        },
        {
            "location": "/scheduler/connectors/#connectors",
            "text": "A connector defines:   The main connector used to manage the state of a resource associated with this connector;  A way to select a single host connector given some computational requirements (e.g. 1G memory);",
            "title": "Connectors"
        },
        {
            "location": "/scheduler/connectors/#localhost",
            "text": "",
            "title": "Localhost"
        },
        {
            "location": "/scheduler/connectors/#ssh",
            "text": "",
            "title": "SSH"
        },
        {
            "location": "/scheduler/connectors/#launchers",
            "text": "Connectors are used to connect to a specific computer in order to execute a command or access a file system.\nHere is the list of available connectors:",
            "title": "Launchers"
        },
        {
            "location": "/scheduler/connectors/#direct-launcher",
            "text": "DirectLauncher : Executes a command via a shell script",
            "title": "Direct launcher"
        },
        {
            "location": "/scheduler/connectors/#oar",
            "text": "OARLauncher : Launches a job through OAR",
            "title": "OAR"
        },
        {
            "location": "/scheduler/connectors/#finding-and-describing-resources",
            "text": "In order to allow full flexibility, resources are described by a URI, which in most cases is a URL (e.g.  file://path/to/my/file ). In order to map back a URI to a connector, Experimaestro has a set of handlers associated with protocols (in order to deal with an URL), and custom handlers can be added.  The same resource can be at different paths depending on the host (i.e. via mounts). In order to deal with that,",
            "title": "Finding and describing resources"
        },
        {
            "location": "/scheduler/connectors/#available-connectors",
            "text": "",
            "title": "Available connectors"
        },
        {
            "location": "/scheduler/connectors/#group",
            "text": "Defines a set of connectors",
            "title": "Group"
        },
        {
            "location": "/scheduler/connectors/#localhost_1",
            "text": "",
            "title": "Localhost"
        },
        {
            "location": "/scheduler/connectors/#ssh_1",
            "text": "",
            "title": "SSH"
        },
        {
            "location": "/scheduler/connectors/#launcher",
            "text": "Launchers are used to define how a command is executed.\n  Here is the list of available launchers:    ShLauncher: runs commands using the  sh  shell    OARLauncher: runs commands using  OAR",
            "title": "Launcher"
        },
        {
            "location": "/scheduler/notification/",
            "text": "It is possible to notify Experimaestro of the progress of a job. If notification is possible, the\nenvironment variable \nXPM_NOTIFICATION_URL\n is set by the launcher. It gives the URL that has\nto be used to notify that something has happened (for the moment, only a progress\nvalue between 0 and 1 is allowed)\n\n\nBash\n\n\nWith \nwget\n\n\ntest \"$XPM_NOTIFICATION_URL\" && wget --quiet -O /dev/null \"$XPM_NOTIFICATION_URL/progress/$progress\"\n\n\n\n\nPython\n\n\nIn Python, the simplest is to use the experimaestro library\n\n\nfrom\n \nexperimaestro\n \nimport\n \nprogress\n\n\n\n# Report progress of 10%\n\n\nprogress\n(\n.\n1\n)\n\n\n\n\n\nLua\n\n\n-- Create a notification function\n\n\n\nxpm_url\n \n=\n \nos.getenv\n(\n\"XPM_NOTIFICATION_URL\"\n)\n\n\n\nif\n \nxpm_url\n \n~=\n \nnil\n \nthen\n\n  \nlocal\n \nhttp\n \n=\n \nrequire\n(\n\"socket.http\"\n)\n\n  \nhttp\n.\nTIMEOUT\n \n=\n \n0.01\n \n-- set timeout to a low value\n\n  \nlocal\n \nlast_value\n \n=\n \n-\n1\n\n  \nfunction\n \nnotify_progress\n(\nprogress\n)\n\n    \nlocal\n \nvalue\n \n=\n \nstring.format\n(\n\"%s/progress/%.3f\"\n,\n \nxpm_url\n,\n \nprogress\n)\n\n    \nif\n \nlast\n \n~=\n \nvalue\n \nthen\n\n      \nlocal\n \nt\n \n=\n \ncoroutine.create\n(\nfunction\n \n()\n \nhttp\n.\nrequest\n(\nvalue\n)\n \nend\n)\n\n      \ncoroutine.resume\n(\nt\n)\n\n      \nlast_value\n \n=\n \nvalue\n\n    \nend\n\n  \nend\n\n\nelse\n\n  \nfunction\n \nnotify_progress\n(\nprogress\n)\n\n  \nend\n\n\nend\n\n\n\n-- Notifies\n\n\nnotify_progress\n(\n0.01\n)",
            "title": "Notification"
        },
        {
            "location": "/scheduler/notification/#bash",
            "text": "With  wget  test \"$XPM_NOTIFICATION_URL\" && wget --quiet -O /dev/null \"$XPM_NOTIFICATION_URL/progress/$progress\"",
            "title": "Bash"
        },
        {
            "location": "/scheduler/notification/#python",
            "text": "In Python, the simplest is to use the experimaestro library  from   experimaestro   import   progress  # Report progress of 10%  progress ( . 1 )",
            "title": "Python"
        },
        {
            "location": "/scheduler/notification/#lua",
            "text": "-- Create a notification function  xpm_url   =   os.getenv ( \"XPM_NOTIFICATION_URL\" )  if   xpm_url   ~=   nil   then \n   local   http   =   require ( \"socket.http\" ) \n   http . TIMEOUT   =   0.01   -- set timeout to a low value \n   local   last_value   =   - 1 \n   function   notify_progress ( progress ) \n     local   value   =   string.format ( \"%s/progress/%.3f\" ,   xpm_url ,   progress ) \n     if   last   ~=   value   then \n       local   t   =   coroutine.create ( function   ()   http . request ( value )   end ) \n       coroutine.resume ( t ) \n       last_value   =   value \n     end \n   end  else \n   function   notify_progress ( progress ) \n   end  end  -- Notifies  notify_progress ( 0.01 )",
            "title": "Lua"
        },
        {
            "location": "/manager/intro/",
            "text": "Manager\n\n\nThe manager is based on the definition of \ntypes\n and \ntasks\n. Tasks are\ntypes that are associated with a way to execute a process.\n\n\nTypes and tasks can be defined in a \nYAML\n file, or, when bindings exist,\ndirectly in the host language. Available bindings are:\n\n\n\n\nPython\n\n\nJava\n\n\n\n\nTypes\n\n\nA type is defined by:\n\n\n\n\nA qualified name\n\n\nA parent\n\n\nA list of arguments \n\n\n\n\n\n\nExample\n\n\nThe following \nYAML\n code defines two types, one\n\n\nmy.model.abstract\n:\n \n{}\n\n\n\nmy.model\n:\n\n  \nparent\n:\n \n\"my.model.abstract\"\n\n  \narguments\n:\n\n    \nparameters\n\n      \ncount\n:\n\n        \ndefault\n:\n \n10\n\n        \nhelp\n:\n \nNumber of nuggets to include\n\n        \ntype\n:\n \ninteger\n\n    \n  \n$seed\n:\n\n        \ndefaut\n:\n \n0\n\n        \ntype\n:\n \nint\n\n        \nhelp\n:\n \nSeed for the model parameters\n\n\n\n\n\n\n\nBasic types\n\n\nThese types are predefined\n\n\n\n\nint\n\n\nreal\n\n\nstring\n\n\n\n\nComplex types\n\n\n\n\narray\n\n\nmap\n\n\n\n\nTasks\n\n\nA task extends a type by associating it with \ncommand to run.\n\n\ntasks\n:\n\n  \nindri.index\n:\n\n    \ntype\n:\n \nindri.index\n\n    \ncommand\n:\n\n      \n-\n \npathref\n:\n \nindri.PYTHON_PATH\n\n      \n-\n \npathref\n:\n \nindri.MAIN_PY\n\n      \n-\n \nrun\n\n      \n-\n \nindri.index\n\n      \n-\n \ntype\n:\n \nparameters",
            "title": "Intro"
        },
        {
            "location": "/manager/intro/#manager",
            "text": "The manager is based on the definition of  types  and  tasks . Tasks are\ntypes that are associated with a way to execute a process.  Types and tasks can be defined in a  YAML  file, or, when bindings exist,\ndirectly in the host language. Available bindings are:   Python  Java",
            "title": "Manager"
        },
        {
            "location": "/manager/intro/#types",
            "text": "A type is defined by:   A qualified name  A parent  A list of arguments     Example  The following  YAML  code defines two types, one  my.model.abstract :   {}  my.model : \n   parent :   \"my.model.abstract\" \n   arguments : \n     parameters \n       count : \n         default :   10 \n         help :   Number of nuggets to include \n         type :   integer \n        $seed : \n         defaut :   0 \n         type :   int \n         help :   Seed for the model parameters",
            "title": "Types"
        },
        {
            "location": "/manager/intro/#basic-types",
            "text": "These types are predefined   int  real  string",
            "title": "Basic types"
        },
        {
            "location": "/manager/intro/#complex-types",
            "text": "array  map",
            "title": "Complex types"
        },
        {
            "location": "/manager/intro/#tasks",
            "text": "A task extends a type by associating it with \ncommand to run.  tasks : \n   indri.index : \n     type :   indri.index \n     command : \n       -   pathref :   indri.PYTHON_PATH \n       -   pathref :   indri.MAIN_PY \n       -   run \n       -   indri.index \n       -   type :   parameters",
            "title": "Tasks"
        },
        {
            "location": "/manager/definitions/",
            "text": "Definitions\n\n\nDefinitions files are in YAML or JSON, and describe the schema of types and tasks.\nIn this document, the examples are in YAML, since the syntax is lighter.\n\n\nA definition file is divided in two sections, \ntypes\n and \ntasks\n, which\nare two dictionaries mapping a type or a task id to its definition. The definition\nis described in\n\n\ntypes\n:\n\n    \ntype1\n:\n\n        \n-\n \na\n:\n \nb\n\n    \ntype2\n:\n\n        \n...\n\n\n\ntasks\n:\n\n    \ntask1\n:\n\n        \n...\n\n    \ntask2\n:\n\n        \n...\n\n\n\n\n\nTypes\n\n\nA type is defined by a dictionary, whose keys can be:\n\n\n\n\narguments\n The arguments that define the type\n\n\ntype\n The type (by defaut, \nany\n)\n\n\nhelp\n A markdown formatted help message for this argument\n\n\ndefault\n or \ngenerator\n provides a default value: \ndefault\n is\n  an object corresponding to the default value\n\n\n\n\nGenerators\n\n\nAt the moment, only one generator is defined.\n\n\ngenerator\n:\n\n    \ntype\n:\n \npath\n\n    \nname\n:\n \nbasename for the generated path\n\n\n\n\n\nTasks",
            "title": "Definitions"
        },
        {
            "location": "/manager/definitions/#definitions",
            "text": "Definitions files are in YAML or JSON, and describe the schema of types and tasks.\nIn this document, the examples are in YAML, since the syntax is lighter.  A definition file is divided in two sections,  types  and  tasks , which\nare two dictionaries mapping a type or a task id to its definition. The definition\nis described in  types : \n     type1 : \n         -   a :   b \n     type2 : \n         ...  tasks : \n     task1 : \n         ... \n     task2 : \n         ...",
            "title": "Definitions"
        },
        {
            "location": "/manager/definitions/#types",
            "text": "A type is defined by a dictionary, whose keys can be:   arguments  The arguments that define the type  type  The type (by defaut,  any )  help  A markdown formatted help message for this argument  default  or  generator  provides a default value:  default  is\n  an object corresponding to the default value",
            "title": "Types"
        },
        {
            "location": "/manager/definitions/#generators",
            "text": "At the moment, only one generator is defined.  generator : \n     type :   path \n     name :   basename for the generated path",
            "title": "Generators"
        },
        {
            "location": "/manager/definitions/#tasks",
            "text": "",
            "title": "Tasks"
        },
        {
            "location": "/manager/json/",
            "text": "Introduction\n\n\nJSON is used to describe resources. Special names are reserved by experimaestro\nto automate some processes. \n\n\n\n\nSignature\n\n\nA key point of JSON objects are that a \nsignature\n can be \ncomputed. This signature allows to identify completely one\nexperimental results by tracing back all its parameters. Signature\ncomputation is explained in \nthis section\n.\n\n\n\n\nWe will make use of an example of a message\n\n\n{\n\n    \n\"alpha\"\n:\n \n3\n,\n\n    \n\"$type\"\n:\n \n\"integer\"\n,\n\n\n}\n\n\n\n\n\nThis document describes the JSON format used by tasks to communicate. Here are the\n  key facts:\n\n\n\n\nAny Json type is a valid message\n\n\nPredefined datatypes are defined in Experimaestro (integers, strings, etc.). Types\n     are given by the \n$type\n tag, or by the type of the value when using\n     JSON primitives.\n\n\nMessages can be compared. This is useful when comparing two resources\n\n\nSpecial tags and/or attributes allows to\n\n\nDefine resources\n\n\nDefine the parameters and their values that were used to generate an output\n\n\n\n\n\n\n\n\nReserved JSON keys\n\n\nSome keys have a special meaning in experimaestro:\n\n\n\n\n$value\n correspond to the simple value of the JSON\n\n\n$type\n correspond to the type of the JSON\n\n\n$tag\n correspond to a tag - those can be used to mark special values (e.g. parameters under study)\n\n\n$resource\n corresponds to an experimaestro resource\n\n\n$default\n default value\n\n\n$path\n the path\n\n\n$ignore\n list of keys to ignore (besides those prefixed by \n$\n)\n\n\n\n\nPredefined types\n\n\n\n\nstring\n for strings\n\n\ninteger\n for boolean\n\n\ninteger\n for integers\n\n\nreal\n for reals\n\n\npath\n for anything corresponding to a file or a directory (even on the network)\n\n\n\n\nSignature\n\n\nEach JSON can be reduced to a signature that corresponds to the JSON describing the factor\nof variation of the outcome of an experiment.\n\n\n\n\nReplacing simple values by their value\n\n\nStripping paths\n\n\nStripping all keys beginning by \n$\n except \n$type\n\n\n\n\n{\n\n  \n\"x\"\n:\n \n{\n \n\"$type\"\n:\n \n\"integer\"\n,\n \n\"$value\"\n:\n \n13\n \n},\n\n  \n\"y\"\n:\n \n{\n\n    \n\"k\"\n:\n \n1\n\n  \n}\n\n  \n\"path\"\n:\n \n{\n \n\"$type\"\n:\n \n\"path\"\n,\n \n\"$value\"\n:\n \n\"/path/to/a/file\"\n \n},\n\n  \n\"$resource\"\n:\n \n\"/uri/of/resource\"\n,\n\n\n}\n\n\n\n\n\nThe signature will be\n\n\n{\n\n  \n\"x\"\n:\n \n13\n,\n\n  \n\"y\"\n:\n \n{\n \n\"k\"\n:\n \n1\n \n}\n\n\n}\n\n\n\n\n\nTags\n\n\nTags are used to mark parameters that are under study, i.e. parameters that the current experiment are interested in looking at.\nWhen a parameter is tagged, the JSON representation adds a \n$tag\n entry that gives the name of the parameter\n\n{\n \n\"$type\"\n:\n \n\"integer\"\n,\n \n\"$value\"\n:\n \n13\n,\n \n\"$tag\"\n:\n \n\"x\"\n \n}\n,\n\n\n\n\nThis can be achieved by calling the function \ntag\n from xpm:\n\nfrom\n \nxpm\n \nimport\n \ntag\n\n\ntag\n(\n\"x\"\n,\n \n1\n)\n\n\n\n\nTags can be retrieved using the \nretrieve_tags\n function.\n\n\nThis can be achieved by calling the function \ntag\n from xpm:\n\nfrom\n \nxpm\n \nimport\n \nretrieve_tags\n\n\nretrieve_tags\n(\njson\n)\n\n\n\n\nIf \njson\n is\n\njson\n \n=\n \n{\n\n\n\"x\"\n:\n \n{\n \n\"$type\"\n:\n \n\"integer\"\n,\n \n\"$value\"\n:\n \n13\n,\n \n\"$tag\"\n:\n \n\"x\"\n \n},\n\n\n\"y\"\n:\n \n{\n \n\"$type\"\n:\n \n\"real\"\n,\n \n\"$value\"\n:\n \n1.2\n,\n \n\"$tag\"\n:\n \n\"y\"\n \n},\n\n\n}\n\n\n\n\nthen the output will be\n\n{\n\n\n\"x\"\n:\n \n{\n \n\"$type\"\n:\n \n\"integer\"\n,\n \n\"$value\"\n:\n \n13\n,\n \n\"$tag\"\n:\n \n\"x\"\n \n},\n\n\n\"y\"\n:\n \n{\n \n\"$type\"\n:\n \n\"real\"\n,\n \n\"$value\"\n:\n \n1.2\n,\n \n\"$tag\"\n:\n \n\"y\"\n \n},\n\n\n\"tags\"\n:\n \n{\n \n\"x\"\n:\n \n1\n,\n \n\"y\"\n:\n \n1.2\n \n}\n\n\n}\n\n\n\n\nThis allows further tasks to use the tags values for building e.g. tables of results.",
            "title": "Output"
        },
        {
            "location": "/manager/json/#introduction",
            "text": "JSON is used to describe resources. Special names are reserved by experimaestro\nto automate some processes.    Signature  A key point of JSON objects are that a  signature  can be \ncomputed. This signature allows to identify completely one\nexperimental results by tracing back all its parameters. Signature\ncomputation is explained in  this section .   We will make use of an example of a message  { \n     \"alpha\" :   3 , \n     \"$type\" :   \"integer\" ,  }   This document describes the JSON format used by tasks to communicate. Here are the\n  key facts:   Any Json type is a valid message  Predefined datatypes are defined in Experimaestro (integers, strings, etc.). Types\n     are given by the  $type  tag, or by the type of the value when using\n     JSON primitives.  Messages can be compared. This is useful when comparing two resources  Special tags and/or attributes allows to  Define resources  Define the parameters and their values that were used to generate an output",
            "title": "Introduction"
        },
        {
            "location": "/manager/json/#reserved-json-keys",
            "text": "Some keys have a special meaning in experimaestro:   $value  correspond to the simple value of the JSON  $type  correspond to the type of the JSON  $tag  correspond to a tag - those can be used to mark special values (e.g. parameters under study)  $resource  corresponds to an experimaestro resource  $default  default value  $path  the path  $ignore  list of keys to ignore (besides those prefixed by  $ )",
            "title": "Reserved JSON keys"
        },
        {
            "location": "/manager/json/#predefined-types",
            "text": "string  for strings  integer  for boolean  integer  for integers  real  for reals  path  for anything corresponding to a file or a directory (even on the network)",
            "title": "Predefined types"
        },
        {
            "location": "/manager/json/#signature",
            "text": "Each JSON can be reduced to a signature that corresponds to the JSON describing the factor\nof variation of the outcome of an experiment.   Replacing simple values by their value  Stripping paths  Stripping all keys beginning by  $  except  $type   { \n   \"x\" :   {   \"$type\" :   \"integer\" ,   \"$value\" :   13   }, \n   \"y\" :   { \n     \"k\" :   1 \n   } \n   \"path\" :   {   \"$type\" :   \"path\" ,   \"$value\" :   \"/path/to/a/file\"   }, \n   \"$resource\" :   \"/uri/of/resource\" ,  }   The signature will be  { \n   \"x\" :   13 , \n   \"y\" :   {   \"k\" :   1   }  }",
            "title": "Signature"
        },
        {
            "location": "/manager/json/#tags",
            "text": "Tags are used to mark parameters that are under study, i.e. parameters that the current experiment are interested in looking at.\nWhen a parameter is tagged, the JSON representation adds a  $tag  entry that gives the name of the parameter {   \"$type\" :   \"integer\" ,   \"$value\" :   13 ,   \"$tag\" :   \"x\"   } ,   This can be achieved by calling the function  tag  from xpm: from   xpm   import   tag  tag ( \"x\" ,   1 )   Tags can be retrieved using the  retrieve_tags  function.  This can be achieved by calling the function  tag  from xpm: from   xpm   import   retrieve_tags  retrieve_tags ( json )   If  json  is json   =   {  \"x\" :   {   \"$type\" :   \"integer\" ,   \"$value\" :   13 ,   \"$tag\" :   \"x\"   },  \"y\" :   {   \"$type\" :   \"real\" ,   \"$value\" :   1.2 ,   \"$tag\" :   \"y\"   },  }   then the output will be {  \"x\" :   {   \"$type\" :   \"integer\" ,   \"$value\" :   13 ,   \"$tag\" :   \"x\"   },  \"y\" :   {   \"$type\" :   \"real\" ,   \"$value\" :   1.2 ,   \"$tag\" :   \"y\"   },  \"tags\" :   {   \"x\" :   1 ,   \"y\" :   1.2   }  }   This allows further tasks to use the tags values for building e.g. tables of results.",
            "title": "Tags"
        },
        {
            "location": "/manager/java/",
            "text": "It is possible to define tasks in Java using introspection\n\n\n@TaskDescription\n(\nid\n \n=\n \n\"mg4j:adhoc\"\n,\n\n        \noutput\n \n=\n \n\"irc:run\"\n,\n\n        \ndescription\n \n=\n \n\"Runs an ad-hoc task\"\n,\n\n        \nregistry\n \n=\n \nRegistry\n.\nclass\n)\n\n\npublic\n \nclass\n \nAdhoc\n \nextends\n \nAbstractTask\n \n{\n\n    \nfinal\n \nprivate\n \nstatic\n \nLogger\n \nLOGGER\n \n=\n \nLoggerFactory\n.\ngetLogger\n(\nAdhoc\n.\nclass\n);\n\n\n    \n@JsonArgument\n(\nname\n \n=\n \n\"top_k\"\n)\n\n    \nint\n \ncapacity\n \n=\n \n1500\n;\n\n\n    \n@JsonArgument\n\n    \nRetrievalModel\n \nmodel\n;\n\n\n    \n@Override\n\n    \npublic\n \nJsonElement\n \nexecute\n(\nJsonObject\n \nr\n,\n \nProgressListener\n \nprogress\n)\n \nthrows\n \nThrowable\n \n{\n\n        \n...\n\n    \n}\n\n\n}",
            "title": "Java"
        },
        {
            "location": "/manager/python/",
            "text": "Python types and tasks can be defined using annotations\n\n\nDefining a type\n\n\nfrom\n \nexperimaestro\n \nimport\n \nTypeArgument\n\n\n\n@TypeArgument\n(\n\"gamma\"\n,\n \ntype\n=\nfloat\n,\n \nrequired\n=\nFalse\n)\n\n\n@RegisterType\n(\n\"my.model\"\n)\n\n\nclass\n \nMyModel\n:\n \npass\n\n\n\n\n\nRunning\n\n\nimport\n \nexperimaestro\n \nas\n \nxpm\n\n\n\n# Put your definitions here:\n\n\n# - load a YAML\n\n\n# - import the definitions\n\n\n\nif\n \n__name__\n \n==\n \n\"__main__\"\n:\n\n    \nxpm\n.\nlogger\n.\nsetLevel\n(\nlogging\n.\nDEBUG\n)\n\n    \nxpm\n.\nsetLogLevel\n(\n\"xpm\"\n,\n \nxpm\n.\nLogLevel_DEBUG\n)\n\n    \nxpm\n.\nsetLogLevel\n(\n\"rpc\"\n,\n \nxpm\n.\nLogLevel_INFO\n)\n\n    \nxpm\n.\nregister\n.\nparse\n()",
            "title": "Python"
        },
        {
            "location": "/manager/python/#defining-a-type",
            "text": "from   experimaestro   import   TypeArgument  @TypeArgument ( \"gamma\" ,   type = float ,   required = False )  @RegisterType ( \"my.model\" )  class   MyModel :   pass",
            "title": "Defining a type"
        },
        {
            "location": "/manager/python/#running",
            "text": "import   experimaestro   as   xpm  # Put your definitions here:  # - load a YAML  # - import the definitions  if   __name__   ==   \"__main__\" : \n     xpm . logger . setLevel ( logging . DEBUG ) \n     xpm . setLogLevel ( \"xpm\" ,   xpm . LogLevel_DEBUG ) \n     xpm . setLogLevel ( \"rpc\" ,   xpm . LogLevel_INFO ) \n     xpm . register . parse ()",
            "title": "Running"
        }
    ]
}